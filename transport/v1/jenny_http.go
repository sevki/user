// Automatically generated by Jenny. DO NOT EDIT!

// Package v1 as generated by Jenny
// Please read about it https://localhost:8080/_spec
package v1

import (
	"context"
	"fmt"
	"net/http"
	"strconv"

	"github.com/Typeform/jenny/encoders"
	"github.com/Typeform/jenny/options"
	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
)

// HTTP transport after this

// HTTP encoders
const ct = "Content-Type"

func encodeGetUserResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {
	produces := []string{}

	resp := response.(_getUserResponse)

	newEnc, mt, err := encoders.ResponseEncoder(ctx, produces)
	if err != nil {
		return err
	}
	w.Header().Set(ct, mt)
	enc := newEnc(w)
	return enc.Encode(resp)
}

// HTTP decoders
func decodeGetUserRequest(ctx context.Context, r *http.Request) (interface{}, error) {

	var err error

	request := _getUserRequest{}

	// Extract ID from query which is a int
	{
		val := ""
		_, ok := r.URL.Query()["id"]
		if ok {
			val = r.URL.Query().Get("id")
		}
		if true && !ok { // if required and doesn't exist throw an error
			return nil, fmt.Errorf("query parameter %q doesn't exist and is required", "id")
		}
		request.ID, err = strconv.Atoi(val)

		if err != nil {
			return nil, err
		}
	}

	return request, err
}

// NewUsersHTTPServer returns a HTTPHandler that can be used with the go std http package
func NewUsersHTTPServer(svc Users, opts ...options.Option) http.Handler {
	r := mux.NewRouter()
	svcOptions := options.New()
	for _, optf := range opts {
		optf(svcOptions)
	}

	{

		getUserEndpoint := makeGetUserEndpoint(svc, svcOptions)
		getUserHandler := httptransport.NewServer(
			getUserEndpoint,
			decodeGetUserRequest,
			encodeGetUserResponse,
			svcOptions.HTTPOptions()...,
		)
		r.Handle("/user", getUserHandler).Methods("GET")
	}

	return r
}
